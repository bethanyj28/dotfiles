export ZSH="$HOME/.oh-my-zsh"

ZSH_THEME="refined"

plugins=(git zsh-autosuggestions zsh-syntax-highlighting)

source $ZSH/oh-my-zsh.sh

# Case-insensitive completion
autoload -U compinit && compinit
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*' menu select
setopt COMPLETE_ALIASES

# Better history search
bindkey '^R' history-incremental-search-backward
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_FIND_NO_DUPS

# Aliases
#
# vim
alias v='nvim'
alias swap='cd ~/.local/share/nvim/swap'
# git
alias gs='git status'
alias master='git checkout master && git pull'
alias main='git checkout main && git pull'
alias gco='git checkout'
alias nb='git checkout -b'
alias yeet='git stash'
# git worktrees
alias wtl='git worktree list'
alias wtp='git worktree prune'
function wta() {
    if [ $# -lt 1 ]; then
        echo "Usage: wta <branch-name> [base-branch]"
        echo "Creates worktree at ../<repo>-<branch-name>"
        return 1
    fi
    local branch=$1
    local base=${2:-HEAD}
    local repo_name=$(basename $(git rev-parse --show-toplevel))
    local worktree_path="../${repo_name}-${branch}"
    git worktree add -b "$branch" "$worktree_path" "$base"
    echo "Created worktree at $worktree_path"
    echo "To start: cd $worktree_path && claude"
}
function wtr() {
    if [ $# -lt 1 ]; then
        echo "Usage: wtr <branch-name>"
        return 1
    fi
    local branch=$1
    local repo_name=$(basename $(git rev-parse --show-toplevel))
    local worktree_path="../${repo_name}-${branch}"
    git worktree remove "$worktree_path"
}
function wtc() {
    if [ $# -lt 1 ]; then
        echo "Usage: wtc <branch-name>"
        return 1
    fi
    local branch=$1
    local repo_name=$(basename $(git rev-parse --show-toplevel))
    cd "../${repo_name}-${branch}"
}
# docker
alias dogs='docker logs -t -f'
alias nuns="docker rmi -f $(docker images | grep '^<none>' | awk '{print $3}')"
# better zsh-ing
alias ll='ls -al'
# Formatting commands
alias jsfmt='prettier --write'
alias gofmt='gofmt -w'
alias jsonf='jq .'
alias yamlf='yq eval . -P'
#gh
alias ghgh='gh cs create -R github/github -s'
alias sshpls='ssh-add .ssh/id_ed25519'
function slop {
    gh slack $1 | pbcopy
}
#go
alias gop='/usr/local/share/goproxy-init.sh --override'

# SSH with Ghostty terminfo transfer
# Usage: ssh-ghostty user@host [additional ssh args]
# Automatically transfers Ghostty's terminfo to the remote server
function ssh-ghostty() {
    if [ $# -eq 0 ]; then
        echo "Usage: ssh-ghostty user@host [additional ssh args]"
        return 1
    fi
    
    # Check if infocmp is available
    if ! command -v infocmp &> /dev/null; then
        echo "Error: infocmp command not found. Please install ncurses-bin or similar package."
        return 1
    fi
    
    # Check if xterm-ghostty terminfo exists locally
    if ! infocmp xterm-ghostty &> /dev/null; then
        echo "Warning: xterm-ghostty terminfo not found locally."
        echo "This function is meant to be used from a Ghostty terminal."
        echo "Falling back to regular SSH..."
        command ssh "$@"
        return $?
    fi
    
    # Transfer terminfo and then connect
    infocmp -x xterm-ghostty | command ssh "$@" -- tic -x - && command ssh "$@"
}

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

export EDITOR="nvim"
export PATH="$PATH:$(go env GOPATH)/bin"

{{ if .codespaces }}
# Go exports
export GOPROXY=https://nobody:${GITHUB_TOKEN}@goproxy.githubapp.com/mod,https://proxy.golang.org/,direct
export GOPRIVATE=
export GONOPROXY=
export GONOSUMDB='github.com/github/*'

# make it not ugly
export LS_COLORS="$LS_COLORS:ow=1;34:tw=1;34:"
{{ end }}

{{ if .work }}
export ANTHROPIC_BASE_URL={{ onepasswordRead "op://Private/CLAUDE_CODE/add more/url" }}
export ANTHROPIC_AUTH_TOKEN={{ onepasswordRead "op://Private/CLAUDE_CODE/add more/password" }}
{{ end }}
